from parse_spec import *

instructions = get_instructions('tools/dsp_codegen/spec')

def generate_operand_assertion(operand):
    size = operand.high_index - operand.low_index + 1
    return f'assert 0 <= {operand.char.lower()} and {operand.char.lower()} < {1 << size}'

def generate_operand_insertion(operand):
    return f'instruction |= ({operand.char.lower()} << {operand.low_index})'

with open('assembler.py', 'w+') as f:
    f.write('''
# This file is automatically generated by generate_assembler.py. 
# Do not edit it manually.
            
instructions = []
''')
    
    for instruction in instructions:
        opcode = instruction.opcode
        operands = instruction.operands

        f.write(f'''    
def {opcode.lower()}({', '.join([f'{op.char.lower()}' for op in reversed(operands)])}):
\t{'\n\t'.join([generate_operand_assertion(op) for op in reversed(operands)])}
        
\tinstruction = {hex(instruction.fixed_repr)}
\t{'\n\t'.join([generate_operand_insertion(op) for op in reversed(operands)])}
\tinstructions.append((instruction, {instruction.size}))
''')
    
    f.write(f'''

def get_label():
    return sum(i[1] for i in instructions) // 16

def assemble():
    byte_list = []
    length = 0

    for instruction in instructions:
        length += instruction[1] // 8
        for byte in range(instruction[1] // 8):
            byte_list.append((instruction[0] >> ((instruction[1] // 8 - byte - 1) * 8)) & 0xff)

    return (byte_list, length)

def get_num_bytes():
    return sum(i[1] // 8 for i in instructions)

def get_num_instructions():
    return len(instructions)
            
def reset():
    global instructions
    instructions = []
''')