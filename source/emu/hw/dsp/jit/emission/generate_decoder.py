from typing import Any
import parse_spec

class Table:
    def __init__(self, size, mask):
        self.size  = size
        self.table = [[] for _ in range(size)]
        self.mask  = mask

    def __getitem__(self, key):
        return self.table[key]

    def __setitem__(self, key, item):
        self.table[key] = item
      
    def __repr__(self):
        return f'Table(size={self.size}, mask={self.mask:x}, table={self.table})'
    
instructions = parse_spec.get_instructions('spec')

def pext(value, mask):
    result = 0

    j = 0
    for i in range(mask.bit_length()):
        if (mask & (1 << i)) != 0:
            if (value & (1 << i)) != 0:
                result |= (1 << j)
            j += 1

    return result

def popcount(value):
    count = 0
    while value:
        count += value & 1
        value >>= 1
    return count

def generate_table_for(instructions, bits_looked_at_so_far = 0):
    if len(instructions) == 1:
        return instructions[0]

    discrimination_mask = 0xffff_ffff_ffff_ffff
    discrimination_mask &= ~bits_looked_at_so_far

    for instruction in instructions:
        fixed_mask = instruction.fixed_mask
        if instruction.size != 16:
            fixed_mask >>= 16

        discrimination_mask &= fixed_mask
    
    bitsize = popcount(discrimination_mask)

    if bitsize == 0:
        return []

    table = Table(1 << bitsize, discrimination_mask)
    tmp_table = [[] for _ in range(1 << bitsize)]

    for instruction in instructions:
        fixed_repr = instruction.fixed_repr
        if instruction.size != 16:
            fixed_repr >>= 16

        index = pext(fixed_repr, discrimination_mask)
        tmp_table[index].append(instruction)
    
    for i in range(1 << bitsize):
        entry = tmp_table[i]

        if len(entry) > 0:
            table[i] = generate_table_for(entry, bits_looked_at_so_far | discrimination_mask)
        else:
            table[i] = None

    return table


def fresh_table_function_name():
    fresh_table_function_name_counter = 0
    while True:
        fresh_table_function_name_counter += 1
        yield f'generated_table_{fresh_table_function_name_counter}'
fresh_table_function_name = fresh_table_function_name()

def write_out_instruction_structs(f, instructions):
    f.write(
f'''struct DspInstruction {{
    DspOpcode opcode;

    union {{
        {'\n\t\t'.join([f"{i.opcode.upper()} {i.opcode.lower()};" for i in reversed(instructions)])}
    }}
}}\n\n''')
    
    f.write(
f'''enum DspOpcode {{
    {'\n\t'.join([f"{i.opcode.upper()}," for i in instructions])}
}}\n\n''') 

    for i in instructions:
        f.write(
f'''struct {i.opcode.upper()} {{
    {'\n\t'.join([f'u16 {op.char.lower()};' for op in i.operands])}
}}\n\n''')

def get_operand_decoding_string(operand, instruction_size):
    if instruction_size == 16:
        return f'instruction.bits({operand.low_index}, {operand.high_index})'
    else:
        if operand.low_index == 0 and operand.high_index == 15:
            return 'next_instruction'
        else:
            assert operand.low_index >= 16 and operand.high_index >= 16, f'Invalid operand indices: {operand.low_index}, {operand.high_index}'
            return f'instruction.bits({operand.low_index - 16}, {operand.high_index - 16})'

def write_out_table(f, function_name, table):
    children = []

    f.write(f'DspInstruction {function_name}(u16 instruction, u16 next_instruction) {{\n')
    
    f.write(f'\tu16 index = 0;\n');
    j = 0
    for i in range(table.mask.bit_length()):
        if (table.mask & (1 << i)) != 0:
            f.write(f'\tindex |= ((instruction & {1 << i:#x}) >> {i}) << {j};\n')
            j += 1
                                            
    f.write(f'\n\tfinal switch (index) {{\n')
    for case_number in range(table.size):
        if isinstance(table[case_number], parse_spec.Instruction):
            instruction = table[case_number]
            f.write(f'\t\tcase {case_number}: return DspInstruction(DspOpcode.{instruction.opcode.upper()}, {instruction.opcode.lower()} : {instruction.opcode.upper()}({", ".join([get_operand_decoding_string(op, instruction.size) for op in reversed(instruction.operands)])}));\n')
        elif table[case_number] is None:
            pass
        else:
            child_function_name = next(fresh_table_function_name)
            f.write(f'\t\tcase {case_number}: return {child_function_name}(instruction, next_instruction);\n')
            children.append((child_function_name, table[case_number]))

    f.write('\t}\n')
    f.write('}\n\n')

    for child in children:
        write_out_table(f, child[0], child[1])

table = generate_table_for(instructions)
with open('decoder.d', 'w+') as f:
    f.write('// This file is automatically generated by generate_decoder.py.\n// Do not edit it manually.\n\n')

    f.write('module emu.hw.dsp.jit.emission.decoder;\n\n')
    f.write('import util.bitop;\n')
    f.write('import util.number;\n')

    f.write('\n')

    write_out_instruction_structs(f, instructions)
    write_out_table(f, 'decode_instruction', table)
