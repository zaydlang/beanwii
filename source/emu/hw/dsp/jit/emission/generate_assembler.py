from parse_spec import *

instructions = get_instructions('spec')

def generate_operand_assertion(operand):
    size = operand.high_index - operand.low_index + 1
    return f'assert 0 <= {operand.char.lower()} and {operand.char.lower()} < {1 << size}'

def generate_operand_insertion(operand):
    return f'instruction |= ({operand.char.lower()} << {operand.low_index})'

with open('assembler.py', 'w+') as f:
    f.write('''
# This file is automatically generated by generate_assembler.py. 
# Do not edit it manually.
            
instructions = []
''')
    
    for instruction in instructions:
        opcode = instruction.opcode
        operands = instruction.operands

        f.write(f'''    
def {opcode}({', '.join([f'{op.char.lower()}' for op in operands])}):
\t{'\n\t'.join([generate_operand_assertion(op) for op in operands])}
        
\tinstruction = {hex(instruction.fixed_repr)}
\t{'\n\t'.join([generate_operand_insertion(op) for op in operands])}
\tinstructions.append(instruction)
''')
    
    